<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8' />
  <title>Tornadoes</title>
  <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
  <link href="https://api.mapbox.com/mapbox-assembly/v0.24.0/assembly.min.css" rel="stylesheet">
  <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.1/mapbox-gl.css' rel='stylesheet' />
  

    <style>
        body {
            margin:0;
            padding:0;
        }
        
    </style>
</head>
<body>

<div class='grid bg-gray-dark absolute h-full w-full'>
    <div class='col col--12 border-b border--white color-white'>
        <h1 class='txt-h2 mx36 my24 inline-block'>Tornado Damage in the US: 2010-2018</h1>
        <p class='fr mr24 mt36'>Source: <a class='link' target='_blank' href='https://www.spc.noaa.gov/gis/svrgis/'>NOAA Storm Prediction Center</a></p>
    </div>
    <div class='col col--3 h-full'>
        <div id ='side-panel' class='txt-s my12 mx12 mb6 color-white'>
            The US experiences an average of 1200 tornadoes every year resulting in billions of dollars in property and crop damage.
            This map shows tornado paths in the US from 2010 to 2018. 
            Use the time slider to explore temporal patterns, and click any tornado path for more details. 
            Paths are symbolized according to their magnitude on the Enhanced Fujita Scale, which categorizes tornadoes according to their wind speed and related damage. 
            This scale uses wind estimates based on damage to specific types of structure.
             
        </div>
    </div>
    <div class='col col--9 h-full relative'>
        <div id='map' class='w-full h-full'></div>
        <div id='time-slider' class='w180 bg-white absolute top left mt18 ml18 round shadow-darken10 px12 py12 txt-s'>
            <strong class='block mb6 txt-l'><label id="month"></label></strong>
            <input id="slider" type="range" min="0" max="11" step="1" value="0" />
        </div>
        <div id='info-box' class='w240 bg-white absolute top right mt18 mr18 round shadow-darken10 px12 py12 txt-s'>
            <strong class='block mb6 txt-l'>Click any tornado path to learn more.</strong>
        </div>
        <div id='legend' class='w180 bg-white absolute top left mt120 ml18 round shadow-darken10 px12 py12 txt-s'>
            <strong class='block mb6 txt-m'>Magnitude: Enhanced Fujita Scale</strong>
            <ul class='ul mb6'></ul>
        </div>
    </div>
</div>

<script async defer src="https://api.mapbox.com/mapbox-assembly/v0.24.0/assembly.js"></script>
<script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.1/mapbox-gl.js'></script>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://npmcdn.com/@turf/turf/turf.min.js"></script>

<script>

    // access token
    mapboxgl.accessToken = 'pk.eyJ1IjoiZWlsZWVuZ3JhZHkiLCJhIjoiY2pvNG00eXVjMDFlcjNxcW1yZ3I2OTJ2ZSJ9.l2EtBykdOJSCNiszd2NbaA';

    // create a new map
    var map = new mapboxgl.Map({
        container: 'map', // container id
        style: 'mapbox://styles/mapbox/dark-v9', // stylesheet location
        center: [-99.00419461981159, 39.09686673109556], // starting position [lng, lat]
        zoom: 3.52 // starting zoom
    });

    // define initial bounds of map to revert to when time slider changes
    var initialBounds = [-60.29801479704621, 46.228291513703226, -137.7103744425777, 31.164291511296398]
     
    var years = [
        '2010',
        '2011',
        '2012',
        '2013',
        '2014',
        '2015',
        '2016',
        '2017',
        '2018'
    ];

    var months = [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December'
    ];

    var colorCodes = {
        0: "#85c4c9",
        1: "#fcde9c",
        2: "#f58670",
        3: "#e34f6f",
        4: "#d72d7c",
        5: "#7c1d6f"
    }

    var labelCodes = {
        0: "EF0",
        1: "EF1",
        2: "EF2",
        3: "EF3",
        4: "EF4",
        5: "EF5"
    }

    var hoveredPathId = null;

    var popup = new mapboxgl.Popup({
        closeButton: false,
        closeOnClick: false
    });

    map.on('load', function() {
        d3.json('data/tornadoes-filtered.json').then(geojson => {

            geojson.features = geojson.features.map(function(d) {
                d.properties.month = new Date(d.properties.date).getMonth();
                return d;
            });

            console.log(geojson);

            addLayer(geojson);
            addLegend(geojson);
        });
    });

    function addLayer(geojson) {
        map.addSource('tornadoes', {
            'type': 'geojson',
            'data': geojson,
            'generateId': true
        });

        map.addLayer({
            'id': 'tornado-paths',
            'type': 'line',
            'source': 'tornadoes', // set data source defined above
            'paint': {
                "line-color": [
                    "match",
                    ["number", ["get", "mag"]],
                    0, colorCodes[0],
                    1, colorCodes[1],
                    2, colorCodes[2],
                    3, colorCodes[3],
                    4, colorCodes[4],
                    5, colorCodes[5],
                    "#000000"
                ],
                "line-opacity": [
                    "case",
                    ["boolean", ["feature-state", "hover"], false],
                    1,
                    0.85
                ],
                "line-width": [
                    "case",
                    ["boolean", ["feature-state", "hover"], false],
                    6,
                    3
                ]
            },
            'layout': {
                "line-cap": "round"
            }
        });

        map.loadImage('images/tornado.png', function(err, image) {
            if (err) throw error;
            map.addImage('tornado', image, {
                'sdf': 'true'
            });
        });

        map.on('mousemove', 'tornado-paths', function(e) {

            map.getCanvas().style.cursor = 'pointer';

            if (e.features.length > 0) {
                if (hoveredPathId) {
                    map.setFeatureState(
                    { source: 'tornadoes', id: hoveredPathId },
                    { hover: false }
                    );
                }
                hoveredPathId = e.features[0].id;
                map.setFeatureState(
                    { source: 'tornadoes', id: hoveredPathId },
                    { hover: true }
                );
            }
        });

        map.on('mouseleave', 'tornado-paths', function() {

            map.getCanvas().style.cursor = '';

            if (hoveredPathId) {
                map.setFeatureState(
                    { source: 'tornadoes', id: hoveredPathId },
                    { hover: false }
                );
            }
            hoveredPathId = null;
        });

        // set intial filter to 2010
        // filterBy(2010);
        filterBy(0);

        document
            .getElementById('slider')
            .addEventListener('input', function(e) {

                // check if the moving tornado icon exists, and remove it if so
                var mapLayer = map.getLayer('point');
                if(typeof mapLayer !== 'undefined') {
                    // Remove map layer & source.
                    map.removeLayer('point').removeSource('point');
                }

                document.getElementById('info-box').innerHTML="<strong class='block mb6 txt-l'>Click any tornado path to learn more.</strong>"

                // revert map to initial bounds
                map.fitBounds(initialBounds);

                // var year = parseInt(e.target.value);
                // filterBy(year);

                var month = parseInt(e.target.value, 10);
                filterBy(month);
            });
    }

    function filterBy(month) {

        var filters = ['==', 'month', month];
        map.setFilter('tornado-paths', filters);
        
        // Set the label to the year
        document.getElementById('month').textContent = months[month];
    }

    function addLegend(geojson) {
        var listItems = '';
        for(var code in colorCodes) {
            listItems += "<li class='li h-full txt-m'><span class='w24 h18 mt6 fl mr12' style='background:" + colorCodes[code] +"'></span>" + labelCodes[code] + "</li>"
        }
        d3.select("#legend ul").html(listItems);
    }

    var steps = 101;

    map.on('click', 'tornado-paths', function(e) {

        let features = map.queryRenderedFeatures(e.point);
        let props = e.features[0].properties

        let windSpeed = getWindSpeed(props.mag)
        let damage = getDamage(props.mag)

        let moreDetails = "<strong class='block mb6 txt-l'>Tornado Details</strong>"
                            +"<p>This tornado struck on " + props.date
                            + " at " +props.time 
                            + " and was a magnitude EF" + props.mag 
                            + " on the Enhanced Fujita Scale. Wind speeds were " + windSpeed 
                            + " mph, causing " + damage 
                            + " damage."

        if (props.loss != 0) {
            moreDetails += "<li class='li h-full txt-s'>Property Loss: $" + e.features[0].properties.loss + " million</li>"
        }
        
        if (props.closs != 0) {
            moreDetails += "<li class='li h-full txt-s'>Crop Loss: $" + props.closs + " million</li>"
        }

        document.getElementById('info-box').innerHTML=moreDetails;

        let coordinates1 = e.features[0].geometry.coordinates;
        let coordinates = [[e.features[0].properties.slon, e.features[0].properties.slat], [e.features[0].properties.elon, e.features[0].properties.elat]];

        let startPoint = [e.features[0].properties.slon, e.features[0].properties.slat];
        let endPoint = [e.features[0].properties.elon, e.features[0].properties.elat];


        
        let bounds = coordinates.reduce(function(bounds, coord) {
            return bounds.extend(coord);
        }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));


        map.fitBounds(bounds, {
            padding: {
                'bottom': 80,
                'left': 200,
                'right': 250,
                'top': 100
            }
        });

        let turfStart = turf.point([e.features[0].properties.slon, e.features[0].properties.slat]);
        let turfEnd = turf.point([e.features[0].properties.elon, e.features[0].properties.elat]);

        map.once('moveend', function(e) {

            let mapLayer = map.getLayer('point');

            if(typeof mapLayer !== 'undefined') {
                // Remove map layer & source.
                map.removeLayer('point').removeSource('point');
            };

            var route = {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'LineString',
                            'coordinates': [coordinates[0], coordinates[1]]
                        }
                    }
                ]
            };

            var movePoint = {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'properties': {},
                        'geometry': {
                            'type': 'Point',
                            'coordinates': coordinates[0]
                        }
                    }
                ]
            };

            let turfStart = turf.point(coordinates[0]);
            let turfEnd = turf.point(coordinates[1]);

            let options = {units: 'miles'};

            let arc = [];

            let lineDistance = turf.distance(turfStart, turfEnd, options);

            for (var i = 0; i < lineDistance; i += lineDistance / steps) {
                let segment = turf.along(route.features[0], i, options);
                arc.push(segment.geometry.coordinates);
            }
            
            route.features[0].geometry.coordinates = arc;

            let counter = 0;

            map.addSource('point', {
                'type': 'geojson',
                'data': movePoint
            });

            map.addLayer({
                'id': 'point',
                'source': 'point',
                'type': 'symbol',
                'layout': {
                    'icon-image': 'tornado',
                    'icon-rotation-alignment': 'map',
                    'icon-allow-overlap': true,
                    'icon-ignore-placement': true,
                    'icon-size': 0.1,
                },
                'paint': {
                    'icon-color': '#9AD8F4'
                }
            });

    

            function animate() {
            // Update point geometry to a new position based on counter denoting
            // the index to access the arc.
            movePoint.features[0].geometry.coordinates =
            route.features[0].geometry.coordinates[counter];
            
            // Update the source with this new data.
            map.getSource('point').setData(movePoint);
            
            // Request the next frame of animation so long the end has not been reached.
            if (counter < steps-1) {
                requestAnimationFrame(animate);
            }
            
            counter = counter + 1;

        }

        animate(counter);

        })
    });

    function getWindSpeed(mag) {
        if (mag === 0) {
            return "between 65 and 85"
        } else if (mag === 1) {
            return "between 86 and 110"
        } else if (mag === 2) {
            return "between 111 and 135"
        } else if (mag === 3) {
            return "between 136 and 165"
        } else if (mag === 4) {
            return "between 166 and 200"
        } else if (mag === 5) {
            return "of more than 200"
        } 
    };

    function getDamage(mag) {
        if (mag === 0) {
            return "light"
        } else if (mag === 1) {
            return "moderate"
        } else if (mag === 2) {
            return "considerable"
        } else if (mag === 3) {
            return "severe"
        } else if (mag === 4) {
            return "devastating"
        } else if (mag === 5) {
            return "incredible"
        } 
    };



</script>

</body>
</html>