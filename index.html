<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8' />
  <title>Tornadoes</title>
  <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
  <link href="https://api.mapbox.com/mapbox-assembly/v0.24.0/assembly.min.css" rel="stylesheet">
  <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.1/mapbox-gl.css' rel='stylesheet' />
  

    <style>
        body {
            margin:0;
            padding:0;
        }
        
    </style>
</head>
<body>

<div class='grid bg-gray-dark absolute h-full w-full'>
    <div class='col col--12 border-b border--white color-white'>
        <h1 class='txt-h2 mx36 my24 inline-block'>Tornadoes</h1>
        <p class='fr mr24 mt36'>Source: <a class='link' target='_blank' href='https://www.spc.noaa.gov/gis/svrgis/'>NOAA Storm Prediction Center</a></p>
    </div>
    <div class='col col--12 h-full relative'>
        <div id='map' class='w-full h-full'></div>
        <div id='time-slider' class='w180 bg-white absolute top right mt18 mr18 round shadow-darken10 px12 py12 txt-s'>
            <label id="year"></label>
            <input id="slider" type="range" min="2010" max="2018" step="1" value="0" />
        </div>
        <div id='legend' class='w180 bg-white absolute top left mt18 mr18 round shadow-darken10 px12 py12 txt-s'>
            <strong class='block mb6 txt-l'>Magnitude, Fujita Scale</strong>
            <ul class='ul mb6'></ul>
        </div>
    </div>
</div>

<script async defer src="https://api.mapbox.com/mapbox-assembly/v0.24.0/assembly.js"></script>
<script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.1/mapbox-gl.js'></script>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://npmcdn.com/@turf/turf/turf.min.js"></script>

<script>

    // access token
    mapboxgl.accessToken = 'pk.eyJ1IjoiZWlsZWVuZ3JhZHkiLCJhIjoiY2pvNG00eXVjMDFlcjNxcW1yZ3I2OTJ2ZSJ9.l2EtBykdOJSCNiszd2NbaA';

    // create a new map
    var map = new mapboxgl.Map({
        container: 'map', // container id
        style: 'mapbox://styles/mapbox/dark-v9', // stylesheet location
        center: [-99.00419461981159, 39.09686673109556], // starting position [lng, lat]
        zoom: 3.52 // starting zoom
    });
     
    var years = [
        '2010',
        '2011',
        '2012',
        '2013',
        '2014',
        '2015',
        '2016',
        '2017',
        '2018'
    ];

    var colorCodes = {
        1: "#fcde9c",
        2: "#f58670",
        3: "#e34f6f",
        4: "#d72d7c",
        5: "#7c1d6f"
    }

    var labelCodes = {
        1: "F1: 73–112 mph winds, moderate damage",
        2: "F2: 113–157 mph winds, considerable damage",
        3: "F3: 158–206 mph winds, severe damage",
        4: "F4: 207–260 mph winds, devastating damage",
        5: "F5: 261–318 mph winds, incredible damage"
    }

    var arrowUrl = 'images/arrow-1.png'

    var hoveredPathId = null;

    map.on('load', function() {
        d3.json('data/tornadoes-1-5.json').then(geojson => {
            addLayer(geojson);
            addLegend(geojson);
        });
    });

    function addLayer(geojson) {
        map.addSource('tornados', {
            'type': 'geojson',
            'data': geojson,
            'generateId': true
        });

        map.addLayer({
            'id': 'tornado-paths',
            'type': 'line',
            'source': 'tornados', // set data source defined above
            'paint': {
                "line-color": [
                    "match",
                    ["number", ["get", "mag"]],
                    1, colorCodes[1],
                    2, colorCodes[2],
                    3, colorCodes[3],
                    4, colorCodes[4],
                    5, colorCodes[5],
                    "#000000"
                ],
                "line-opacity": [
                    "case",
                    ["boolean", ["feature-state", "hover"], false],
                    1,
                    0.75
                ],
                "line-width": [
                    "case",
                    ["boolean", ["feature-state", "hover"], false],
                    5,
                    3
                ]
            },
            'layout': {
                "line-cap": "round"
            }
        });

        map.loadImage('images/arrow.png', function(err, image) {
            if (err) throw error;
            map.addImage('arrow', image, {
                'sdf': 'true'
            });
        //     map.addLayer({
        //         'id': 'arrowId',
        //         'type': 'symbol',
        //         'source': 'tornados',
        //         'layout': {
        //             'symbol-placement': 'line',
        //             'symbol-spacing': 1,
        //             'icon-allow-overlap': true,
        //             // 'icon-ignore-placement': true,
        //             'icon-image': 'arrow',
        //             'icon-size': 0.06,
        //             'visibility': 'visible'
        //         },
        //         'paint': {
        //             "icon-color": "#7c1d6f"
        //             // [
        //             //     "match",
        //             //     ["number", ["get", "mag"]],
        //             //     1, colorCodes[1],
        //             //     2, colorCodes[2],
        //             //     3, colorCodes[3],
        //             //     4, colorCodes[4],
        //             //     5, colorCodes[5],
        //             //     "#000000"
        //             // ],
        //         }
        //     });
        });

        map.on('mousemove', 'tornado-paths', function(e) {
            if (e.features.length > 0) {
                if (hoveredPathId) {
                    map.setFeatureState(
                    { source: 'tornados', id: hoveredPathId },
                    { hover: false }
                    );
                }
                hoveredPathId = e.features[0].id;
                map.setFeatureState(
                    { source: 'tornados', id: hoveredPathId },
                    { hover: true }
                );
            }
        });

        map.on('mouseleave', 'tornado-paths', function() {
            if (hoveredPathId) {
                map.setFeatureState(
                    { source: 'tornados', id: hoveredPathId },
                    { hover: false }
                );
            }
            hoveredPathId = null;
        });

        // set intial filter to 2010
        filterBy(2010);

        document
            .getElementById('slider')
            .addEventListener('input', function(e) {
                var year = parseInt(e.target.value);
                filterBy(year);
            });
    }

    function filterBy(year) {
        var filters = ['==', 'yr', year];
        map.setFilter('tornado-paths', filters);
        // map.setFilter('earthquake-labels', filters);
        
        // Set the label to the year
        document.getElementById('year').textContent = years[year];
    }

    function addLegend(geojson) {
        var listItems = '';
        for(var code in colorCodes) {
            listItems += "<li class='li h-full txt-m'><span class='w24 h18 mt6 fl mr12' style='background:" + colorCodes[code] +"'></span>" + labelCodes[code] + "</li>"
        }
        d3.select("#legend ul").html(listItems);
    }

    // var coordinates;
    // var startPoint;
    // var endPoint;
    // var turfStart;
    // var turfEnd;
    // var brng;
    // var midpoint;
    // var movePoint;
    // // var route;
    // var arc = [];
    var steps = 30;
    // var movePointSource;
    // var movePointLayer;

    map.on('click', 'tornado-paths', function(e) {

        var coordinates = [e.features[0].properties.slon, e.features[0].properties.slat];

        var turfStart = turf.point([e.features[0].properties.slon, e.features[0].properties.slat]);
        var turfEnd = turf.point([e.features[0].properties.elon, e.features[0].properties.elat]);
        // console.log(startPoint)

        var brng = turf.bearing(turfStart, turfEnd);

        var startPoint = [e.features[0].properties.slon, e.features[0].properties.slat];
        var endPoint = [e.features[0].properties.elon, e.features[0].properties.elat];

        var line = turf.lineString(e.features[0].geometry.coordinates)
        var bbox = turf.bbox(line);
        // console.log(bbox);

        map.fitBounds(bbox, {
            padding: 40
        });

        map.on('moveend', function(e) {

            var mapLayer = map.getLayer('point');

            if(typeof mapLayer !== 'undefined') {
                console.log('done');
                // Remove map layer & source.
                map.removeLayer('point').removeSource('point');
            } 

            var movePoint = {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'properties': {},
                        'geometry': {
                            'type': 'Point',
                            'coordinates': startPoint
                        }
                    }
                ]
            };

            var route = {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'LineString',
                            'coordinates': [startPoint, endPoint]
                    }
                    }
                ]
                };

            var options = {units: 'miles'};

            var arc = [];

            var lineDistance = turf.distance(turfStart, turfEnd, options);

            for (var i = 0; i < lineDistance; i += lineDistance / steps) {
                var segment = turf.along(route.features[0], i, options);
                arc.push(segment.geometry.coordinates);
            }
            
            route.features[0].geometry.coordinates = arc;

            var counter = 0;

            // if (movePointLayer != undefined) {
            //     map.removeLayer('point');
            //     map.removeSource('point');
            //     console.log('done')
            // }

            map.addSource('point', {
                'type': 'geojson',
                'data': movePoint
            });

            map.addLayer({
                'id': 'point',
                'source': 'point',
                'type': 'symbol',
                'layout': {
                    'icon-image': 'arrow',
                    'icon-rotate': brng,
                    'icon-rotation-alignment': 'map',
                    'icon-allow-overlap': true,
                    'icon-ignore-placement': true,
                    'icon-size': 0.06,
                }
            });

            // map.flyTo({
            //     center: coordinates,
            //     zoom: 10,
            //     pitch: 30,
            //     bearing: brng
            // })

            function animate() {
            // Update point geometry to a new position based on counter denoting
            // the index to access the arc.
            movePoint.features[0].geometry.coordinates =
            route.features[0].geometry.coordinates[counter];
            
            // Calculate the bearing to ensure the icon is rotated to match the route arc
            // The bearing is calculate between the current point and the next point, except
            // at the end of the arc use the previous point and the current point
            // movePoint.features[0].properties.bearing = turf.bearing(
            // turf.point(
            // route.features[0].geometry.coordinates[
            // counter >= steps ? counter - 1 : counter
            // ]
            // ),
            // turf.point(
            // route.features[0].geometry.coordinates[
            // counter >= steps ? counter : counter + 1
            // ]
            // )
            // );
            
            // Update the source with this new data.
            map.getSource('point').setData(movePoint);
            
            // Request the next frame of animation so long the end has not been reached.
            if (counter < steps) {
                requestAnimationFrame(animate);
            }
            
            counter = counter + 1;
        }

            animate(counter);

        })
    });

    //     movePoint = {
    //         'type': 'FeatureCollection',
    //         'features': [
    //             {
    //                 'type': 'Feature',
    //                 'properties': {},
    //                 'geometry': {
    //                     'type': 'Point',
    //                     'coordinates': startPoint
    //                 }
    //             }
    //         ]
    //     };

    //     var route = {
    //         'type': 'FeatureCollection',
    //         'features': [
    //             {
    //                 'type': 'Feature',
    //                 'geometry': {
    //                     'type': 'LineString',
    //                     'coordinates': [[e.features[0].properties.slon, e.features[0].properties.slat], [e.features[0].properties.elon, e.features[0].properties.elat]]
    //             }
    //             }
    //         ]
    //         };
    //     console.log(route);

    //     var options = {units: 'miles'};

    //     var lineDistance = turf.distance(startPoint, endPoint, options);
    //     console.log(lineDistance);

    //     for (var i = 0; i < lineDistance; i += lineDistance / steps) {
    //         var segment = turf.along(route.features[0], i, options);
    //         arc.push(segment.geometry.coordinates);
    //     }
        
    //     console.log(arc);

    //     route.features[0].geometry.coordinates = arc;

    //     var counter = 0;

    //     map.addSource('point', {
    //         'type': 'geojson',
    //         'data': movePoint
    //     });

    //     map.addLayer({
    //         'id': 'point',
    //         'source': 'point',
    //         'type': 'symbol',
    //         'layout': {
    //             'icon-image': 'arrow',
    //             'icon-rotate': ['get', 'bearing'],
    //             'icon-rotation-alignment': 'map',
    //             'icon-allow-overlap': true,
    //             'icon-ignore-placement': true,
    //             'icon-size': 0.06,
    //         }
    //     });

    //     // map.flyTo({
    //     //     center: coordinates,
    //     //     zoom: 10,
    //     //     pitch: 30,
    //     //     bearing: brng
    //     // })

    //     function animate() {
    //     // Update point geometry to a new position based on counter denoting
    //     // the index to access the arc.
    //     movePoint.features[0].geometry.coordinates =
    //     route.features[0].geometry.coordinates[counter];
        
    //     // Calculate the bearing to ensure the icon is rotated to match the route arc
    //     // The bearing is calculate between the current point and the next point, except
    //     // at the end of the arc use the previous point and the current point
    //     movePoint.features[0].properties.bearing = turf.bearing(
    //     turf.point(
    //     route.features[0].geometry.coordinates[
    //     counter >= steps ? counter - 1 : counter
    //     ]
    //     ),
    //     turf.point(
    //     route.features[0].geometry.coordinates[
    //     counter >= steps ? counter : counter + 1
    //     ]
    //     )
    //     );
        
    //     // Update the source with this new data.
    //     map.getSource('point').setData(movePoint);
        
    //     // Request the next frame of animation so long the end has not been reached.
    //     if (counter < steps) {
    //     requestAnimationFrame(animate);
    //     }
        
    //     counter = counter + 1;
    // }


    //     animate(counter);

    // })

    
    // function animate() {
    //     // Update point geometry to a new position based on counter denoting
    //     // the index to access the arc.
    //     movePoint.features[0].geometry.coordinates =
    //     route.features[0].geometry.coordinates[counter];
        
    //     // Calculate the bearing to ensure the icon is rotated to match the route arc
    //     // The bearing is calculate between the current point and the next point, except
    //     // at the end of the arc use the previous point and the current point
    //     movePoint.features[0].properties.bearing = turf.bearing(
    //     turf.point(
    //     route.features[0].geometry.coordinates[
    //     counter >= steps ? counter - 1 : counter
    //     ]
    //     ),
    //     turf.point(
    //     route.features[0].geometry.coordinates[
    //     counter >= steps ? counter : counter + 1
    //     ]
    //     )
    //     );
        
    //     // Update the source with this new data.
    //     map.getSource('point').setData(movePoint);
        
    //     // Request the next frame of animation so long the end has not been reached.
    //     if (counter < steps) {
    //     requestAnimationFrame(animate);
    //     }
        
    //     counter = counter + 1;
    // }

</script>

</body>
</html>